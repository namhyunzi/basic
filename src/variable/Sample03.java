package variable;

public class Sample03 {

	public static void main(String[] args) {
		// 실수 자료형
		/*
		 * float, double
		 * 실수형의 default 자료형은 double이다.
		 * 실수값의 대부분 double타입의 변수로 다룬다.
		 * (float타입의 변수를 사용하는 경우가 거의 없다.)
		 */
		
		// 실수형 변수의 생성과 초기화
		double num1 = 3.14;
		double num2 = 123.4;
		double num3 = 1.234e2;	// e2는 10의 2제곱이다.
		
		float num4 = 3.14f; // 실수의 기본타입이 double이기 때문에
							// 실수값은 언제나 double타입의 값으로 생각한다.
							// 따라서, 실수값을 float타입의 변수에 대입할 때는
							// 이 실수값을 double이 아닌 float타입으로 생각하게 해야한다.
							// 그래서, 실구끝에 F나 f를 붙인다.
		
		System.out.println("num1의 값: " + num1);
		System.out.println("num2의 값: " + num2);
		System.out.println("num3의 값: " + num3);
		System.out.println("num4의 값: " + num4);
		
		// 실수값의 연산
		//		실수값의 연산은 프로그램에서 실수를 저장하는 방식 때문에 
		//		계산결과에 오차가 발생할 수 있다.
		double num5 = 0.1;
		double num6 = 0.2;
		double num7 = num5 + num6;
		System.out.println("num7의 값: "+ num7); // 결과: 0.30000000000000004
		
		
		
	}

}
/*
 * 실수를 저장하는 방식 : 부동소수점 방식
 * 
 * 실수 = 부호 + 지수부 + 가수부
 * 예)
 * 		-118.625	부동소수점 방식으로 저장하기
 * 					(float 타입 기준)
 * 					부호비트(1비트) + 지수부(8비트) + 가수부(23비트)
 * 
 * 		1. 음수기 때문에 최상위 부호비트는 1이다.
 * 		2. 절대값 118.625를 이진법으로 변환한다.
 * 			정수부를 변한
 * 				118 ----> 1110110
 * 				0.625 --> 101
 * 			결과 
 * 				118.625 ---> 1110110.101
 * 		3. 소수점을 이동시켜서 정수부가 한자리가 되도록 조정한다.
 * 				1110110.101 ---> 1.110110101*2^6
 * 		4. 지수부에 127을 더한다.
 * 				6 + 127 = 133 ---> 10000101
 * 		5. 부동소수점 방식으로 저장된 -118.625
 * 				1 10000101 11101101010000000000000
 * 			  부호  지수부   가수부
 * 
 *  * 부동소수점 방식으로 실수를 저장하면, 
 *    0.625와 같이 이진수 소수점으로 닥 떨어지는 수는 문제가 없지만, 0.1과 같이
 *    0.00110011001100110011... 로 무한반복 되는 이진수 실수는 아무리 큰 수를 저장하는
 *    부동소두점 방식이라도 메모리의 한계 때문에 어느부분에서 끊어서 반올림 할 수 밖에 없다.
 *    따라서, 컴퓨터에서 실수값을 표현할 때는 그 값과 가장 가까운 값이 저장된다.
 *    실수값의 계산 결과는 연산오차가 발생할 수 있다.
 *    
 *    연산오차를 해결하기 위해서는
 *    	1. 실수값을 정수형으로 변환한 다음에 계산한다.
 *    		0.1 + 0.2 = (0.1*10 + 0.2*10)/10
 *    	2. BigDecimal 클래스를 이용해서 계산한다.
 */
